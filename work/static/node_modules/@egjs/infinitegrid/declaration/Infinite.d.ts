import Component from "@egjs/component";
export interface OnInfiniteRequestAppend {
    key?: string | number | undefined;
    nextKey?: string | number | undefined;
    nextKeys?: Array<string | number>;
    isVirtual: boolean;
}
export interface OnInfiniteRequestPrepend {
    key?: string | number;
    nextKey?: string | number;
    nextKeys?: Array<string | number>;
    isVirtual: boolean;
}
export interface OnInfiniteChange {
    prevStartCursor: number;
    prevEndCursor: number;
    nextStartCursor: number;
    nextEndCursor: number;
}
export interface InfiniteEvents {
    requestAppend: OnInfiniteRequestAppend;
    requestPrepend: OnInfiniteRequestPrepend;
    change: OnInfiniteChange;
}
export interface InfiniteOptions {
    useRecycle?: boolean;
    threshold?: number;
    defaultDirection?: "start" | "end";
}
export interface InfiniteItem {
    key: string | number;
    startOutline: number[];
    endOutline: number[];
    isVirtual?: boolean;
}
export declare class Infinite extends Component<InfiniteEvents> {
    options: Required<InfiniteOptions>;
    protected startCursor: number;
    protected endCursor: number;
    protected size: number;
    protected items: InfiniteItem[];
    protected itemKeys: Record<string | number, InfiniteItem>;
    constructor(options: InfiniteOptions);
    scroll(scrollPos: number): void;
    /**
     * Call the requestAppend or requestPrepend event to fill the virtual items.
     * @ko virtual item을 채우기 위해 requestAppend 또는 requestPrepend 이벤트를 호출합니다.
     * @return - Whether the event is called. <ko>이벤트를 호출했는지 여부.</ko>
     */
    _requestVirtualItems(): boolean;
    setCursors(startCursor: number, endCursor: number): void;
    setSize(size: number): void;
    getStartCursor(): number;
    getEndCursor(): number;
    isLoading(direction: "start" | "end"): boolean;
    setItems(nextItems: InfiniteItem[]): void;
    syncItems(nextItems: InfiniteItem[]): boolean;
    getItems(): InfiniteItem[];
    getVisibleItems(): InfiniteItem[];
    getItemByKey(key: string | number): InfiniteItem;
    getRenderedVisibleItems(): InfiniteItem[];
    destroy(): void;
}
