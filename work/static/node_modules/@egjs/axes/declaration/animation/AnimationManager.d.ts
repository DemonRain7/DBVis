import { Axis, AxisManager } from "../AxisManager";
import { InterruptManager } from "../InterruptManager";
import { EventManager, ChangeEventOption } from "../EventManager";
import { AxesOption } from "../Axes";
import { AnimationParam, UpdateAnimationOption } from "../types";
export interface AnimationState {
    pos: Axis;
    easingPer: number;
    finished: boolean;
}
export declare abstract class AnimationManager {
    interruptManager: InterruptManager;
    eventManager: EventManager;
    axisManager: AxisManager;
    protected _options: AxesOption;
    protected _animateParam: AnimationParam;
    private _raf;
    constructor({ options, interruptManager, eventManager, axisManager, }: {
        options: AxesOption;
        interruptManager: InterruptManager;
        eventManager: EventManager;
        axisManager: AxisManager;
    });
    abstract interpolate(displacement: number, threshold: number): number;
    abstract updateAnimation(options: UpdateAnimationOption): void;
    protected abstract _initState(info: AnimationParam): AnimationState;
    protected abstract _getNextState(prevState: AnimationState): AnimationState;
    getDuration(depaPos: Axis, destPos: Axis, wishDuration?: number): number;
    getDisplacement(velocity: number[]): number[];
    stopAnimation(option?: ChangeEventOption): void;
    getEventInfo(): ChangeEventOption;
    restore(option: ChangeEventOption): void;
    animationEnd(): void;
    finish(isTrusted: boolean): void;
    getUserControl(param: AnimationParam): {
        destPos: Axis;
        duration: number;
    };
    animateTo(destPos: Axis, duration: number, option?: ChangeEventOption): void;
    setTo(pos: Axis, duration?: number): this;
    setBy(pos: Axis, duration?: number): this;
    private _createAnimationParam;
    private _animateLoop;
    private _getFinalPos;
    private _getRoundUnit;
}
