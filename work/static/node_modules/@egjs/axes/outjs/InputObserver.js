var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { toAxis } from "./inputType/InputType";
import { isOutside, getInsidePosition, getCirculatedPos, isEndofBounce, } from "./Coordinate";
import { map, equal } from "./utils";
var InputObserver = (function () {
    function InputObserver(_a) {
        var options = _a.options, interruptManager = _a.interruptManager, eventManager = _a.eventManager, axisManager = _a.axisManager, animationManager = _a.animationManager;
        this._isOutside = false;
        this._moveDistance = null;
        this._isStopped = false;
        this.options = options;
        this._interruptManager = interruptManager;
        this._eventManager = eventManager;
        this._axisManager = axisManager;
        this._animationManager = animationManager;
    }
    InputObserver.prototype.get = function (input) {
        return this._axisManager.get(input.axes);
    };
    InputObserver.prototype.hold = function (input, event) {
        if (this._interruptManager.isInterrupted() || !input.axes.length) {
            return;
        }
        var changeOption = {
            input: input,
            event: event,
        };
        this._isStopped = false;
        this._interruptManager.setInterrupt(true);
        this._animationManager.stopAnimation(changeOption);
        if (!this._moveDistance) {
            this._eventManager.hold(this._axisManager.get(), changeOption);
        }
        this._isOutside = this._axisManager.isOutside(input.axes);
        this._moveDistance = this._axisManager.get(input.axes);
    };
    InputObserver.prototype.change = function (input, event, offset, useAnimation) {
        if (this._isStopped ||
            !this._interruptManager.isInterrupting() ||
            this._axisManager.every(offset, function (v) { return v === 0; })) {
            return;
        }
        var nativeEvent = event.srcEvent ? event.srcEvent : event;
        if (nativeEvent.__childrenAxesAlreadyChanged) {
            return;
        }
        var depaPos = this._moveDistance || this._axisManager.get(input.axes);
        var destPos;
        destPos = map(depaPos, function (v, k) { return v + (offset[k] || 0); });
        if (this._moveDistance) {
            this._moveDistance = this._axisManager.map(destPos, function (v, _a) {
                var circular = _a.circular, range = _a.range;
                return circular && (circular[0] || circular[1])
                    ? getCirculatedPos(v, range, circular)
                    : v;
            });
        }
        if (this._isOutside &&
            this._axisManager.every(depaPos, function (v, opt) { return !isOutside(v, opt.range); })) {
            this._isOutside = false;
        }
        depaPos = this._atOutside(depaPos);
        destPos = this._atOutside(destPos);
        if (!this.options.nested || !this._isEndofAxis(offset, depaPos, destPos)) {
            nativeEvent.__childrenAxesAlreadyChanged = true;
        }
        var changeOption = {
            input: input,
            event: event,
        };
        if (useAnimation) {
            var duration = this._animationManager.getDuration(destPos, depaPos);
            this._animationManager.animateTo(destPos, duration, changeOption);
        }
        else {
            var isCanceled = !this._eventManager.triggerChange(destPos, depaPos, changeOption, true);
            if (isCanceled) {
                this._isStopped = true;
                this._moveDistance = null;
                this._animationManager.finish(false);
            }
        }
    };
    InputObserver.prototype.release = function (input, event, velocity, inputDuration) {
        if (this._isStopped ||
            !this._interruptManager.isInterrupting() ||
            !this._moveDistance) {
            return;
        }
        var nativeEvent = event.srcEvent ? event.srcEvent : event;
        if (nativeEvent.__childrenAxesAlreadyReleased) {
            velocity = velocity.map(function () { return 0; });
        }
        var pos = this._axisManager.get(input.axes);
        var depaPos = this._axisManager.get();
        var displacement = this._animationManager.getDisplacement(velocity);
        var offset = toAxis(input.axes, displacement);
        var destPos = this._axisManager.get(this._axisManager.map(offset, function (v, opt, k) {
            if (opt.circular && (opt.circular[0] || opt.circular[1])) {
                return pos[k] + v;
            }
            else {
                return getInsidePosition(pos[k] + v, opt.range, opt.circular, opt.bounce);
            }
        }));
        nativeEvent.__childrenAxesAlreadyReleased = true;
        var duration = this._animationManager.getDuration(destPos, pos, inputDuration);
        if (duration === 0) {
            destPos = __assign({}, depaPos);
        }
        var param = {
            depaPos: depaPos,
            destPos: destPos,
            duration: duration,
            delta: this._axisManager.getDelta(depaPos, destPos),
            inputEvent: event,
            input: input,
            isTrusted: true,
        };
        this._eventManager.triggerRelease(param);
        this._moveDistance = null;
        var userWish = this._animationManager.getUserControl(param);
        var isEqual = equal(userWish.destPos, depaPos);
        var changeOption = {
            input: input,
            event: event,
        };
        if (isEqual || userWish.duration === 0) {
            if (!isEqual) {
                this._eventManager.triggerChange(userWish.destPos, depaPos, changeOption, true);
            }
            this._interruptManager.setInterrupt(false);
            if (this._axisManager.isOutside()) {
                this._animationManager.restore(changeOption);
            }
            else {
                this._eventManager.triggerFinish(true);
            }
        }
        else {
            this._animationManager.animateTo(userWish.destPos, userWish.duration, changeOption);
        }
    };
    InputObserver.prototype._atOutside = function (pos) {
        var _this = this;
        if (this._isOutside) {
            return this._axisManager.map(pos, function (v, opt) {
                var tn = opt.range[0] - opt.bounce[0];
                var tx = opt.range[1] + opt.bounce[1];
                return v > tx ? tx : v < tn ? tn : v;
            });
        }
        else {
            return this._axisManager.map(pos, function (v, opt) {
                var min = opt.range[0];
                var max = opt.range[1];
                var out = opt.bounce;
                var circular = opt.circular;
                if ((circular[0] && v < min) || (circular[1] && v > max)) {
                    return v;
                }
                else if (v < min) {
                    return (min - _this._animationManager.interpolate(min - v, out[0]));
                }
                else if (v > max) {
                    return (max + _this._animationManager.interpolate(v - max, out[1]));
                }
                return v;
            });
        }
    };
    InputObserver.prototype._isEndofAxis = function (offset, depaPos, destPos) {
        return this._axisManager.every(depaPos, function (value, option, key) {
            return offset[key] === 0 ||
                (depaPos[key] === destPos[key] &&
                    isEndofBounce(value, option.range, option.bounce, option.circular));
        });
    };
    return InputObserver;
}());
export { InputObserver };
//# sourceMappingURL=InputObserver.js.map