var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { getCirculatedPos } from "../Coordinate";
import { map } from "../utils";
import { AnimationManager } from "./AnimationManager";
var EasingManager = (function (_super) {
    __extends(EasingManager, _super);
    function EasingManager() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._useDuration = true;
        return _this;
    }
    EasingManager.prototype.interpolate = function (displacement, threshold) {
        var initSlope = this._easing(0.00001) / 0.00001;
        return this._easing(displacement / (threshold * initSlope)) * threshold;
    };
    EasingManager.prototype.updateAnimation = function (options) {
        var _a;
        var animateParam = this._animateParam;
        if (!animateParam) {
            return;
        }
        var diffTime = new Date().getTime() - animateParam.startTime;
        var pos = (options === null || options === void 0 ? void 0 : options.destPos) || animateParam.destPos;
        var duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : animateParam.duration;
        if ((options === null || options === void 0 ? void 0 : options.restart) || duration <= diffTime) {
            this.setTo(pos, duration - diffTime);
            return;
        }
        if (options === null || options === void 0 ? void 0 : options.destPos) {
            var currentPos = this.axisManager.get();
            this._initialEasingPer = this._prevEasingPer;
            animateParam.delta = this.axisManager.getDelta(currentPos, pos);
            animateParam.destPos = pos;
        }
        if (options === null || options === void 0 ? void 0 : options.duration) {
            var ratio = (diffTime + this._durationOffset) / animateParam.duration;
            this._durationOffset = ratio * duration - diffTime;
            animateParam.duration = duration;
        }
    };
    EasingManager.prototype._initState = function (info) {
        this._initialEasingPer = 0;
        this._prevEasingPer = 0;
        this._durationOffset = 0;
        return {
            pos: info.depaPos,
            easingPer: 0,
            finished: false,
        };
    };
    EasingManager.prototype._getNextState = function (prevState) {
        var _this = this;
        var animateParam = this._animateParam;
        var prevPos = prevState.pos;
        var destPos = animateParam.destPos;
        var directions = map(prevPos, function (value, key) {
            return value <= destPos[key] ? 1 : -1;
        });
        var diffTime = new Date().getTime() - animateParam.startTime;
        var ratio = (diffTime + this._durationOffset) / animateParam.duration;
        var easingPer = this._easing(ratio);
        var toPos = this.axisManager.map(prevPos, function (pos, options, key) {
            var nextPos = ratio >= 1
                ? destPos[key]
                : pos +
                    (animateParam.delta[key] * (easingPer - _this._prevEasingPer)) /
                        (1 - _this._initialEasingPer);
            var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);
            if (nextPos !== circulatedPos) {
                var rangeOffset = directions[key] * (options.range[1] - options.range[0]);
                destPos[key] -= rangeOffset;
                prevPos[key] -= rangeOffset;
            }
            return circulatedPos;
        });
        this._prevEasingPer = easingPer;
        return {
            pos: toPos,
            easingPer: easingPer,
            finished: easingPer >= 1,
        };
    };
    EasingManager.prototype._easing = function (p) {
        return p > 1 ? 1 : this._options.easing(p);
    };
    return EasingManager;
}(AnimationManager));
export { EasingManager };
//# sourceMappingURL=EasingManager.js.map