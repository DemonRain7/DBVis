var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { ComponentEvent } from "@egjs/component";
import { getObserver } from "@cfcs/core";
import { roundNumbers } from "./utils";
var EventManager = (function () {
    function EventManager(_axes) {
        this._axes = _axes;
    }
    EventManager.prototype.hold = function (pos, option) {
        var roundPos = this._getRoundPos(pos).roundPos;
        this._axes.trigger(new ComponentEvent("hold", {
            pos: roundPos,
            input: option.input || null,
            inputEvent: option.event || null,
            isTrusted: true,
        }));
    };
    EventManager.prototype.triggerRelease = function (param) {
        var _a = this._getRoundPos(param.destPos, param.depaPos), roundPos = _a.roundPos, roundDepa = _a.roundDepa;
        param.destPos = roundPos;
        param.depaPos = roundDepa;
        param.setTo = this._createUserControll(param.destPos, param.duration);
        this._axes.trigger(new ComponentEvent("release", __assign(__assign({}, param), { bounceRatio: this._getBounceRatio(roundPos) })));
    };
    EventManager.prototype.triggerChange = function (pos, depaPos, option, holding) {
        var _this = this;
        if (holding === void 0) { holding = false; }
        var animationManager = this.animationManager;
        var axisManager = animationManager.axisManager;
        var eventInfo = animationManager.getEventInfo();
        var _a = this._getRoundPos(pos, depaPos), roundPos = _a.roundPos, roundDepa = _a.roundDepa;
        var moveTo = axisManager.moveTo(roundPos, roundDepa);
        var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.event) || null;
        var param = {
            pos: moveTo.pos,
            delta: moveTo.delta,
            bounceRatio: this._getBounceRatio(moveTo.pos),
            holding: holding,
            inputEvent: inputEvent,
            isTrusted: !!inputEvent,
            input: (option === null || option === void 0 ? void 0 : option.input) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.input) || null,
            set: inputEvent ? this._createUserControll(moveTo.pos) : function () { },
        };
        var event = new ComponentEvent("change", param);
        this._axes.trigger(event);
        Object.keys(moveTo.pos).forEach(function (axis) {
            var p = moveTo.pos[axis];
            getObserver(_this._axes, axis, p).current = p;
        });
        if (inputEvent) {
            axisManager.set(param.set().destPos);
        }
        return !event.isCanceled();
    };
    EventManager.prototype.triggerAnimationStart = function (param) {
        var _a = this._getRoundPos(param.destPos, param.depaPos), roundPos = _a.roundPos, roundDepa = _a.roundDepa;
        param.destPos = roundPos;
        param.depaPos = roundDepa;
        param.setTo = this._createUserControll(param.destPos, param.duration);
        var event = new ComponentEvent("animationStart", param);
        this._axes.trigger(event);
        return !event.isCanceled();
    };
    EventManager.prototype.triggerAnimationEnd = function (isTrusted) {
        if (isTrusted === void 0) { isTrusted = false; }
        this._axes.trigger(new ComponentEvent("animationEnd", {
            isTrusted: isTrusted,
        }));
    };
    EventManager.prototype.triggerFinish = function (isTrusted) {
        if (isTrusted === void 0) { isTrusted = false; }
        this._axes.trigger(new ComponentEvent("finish", {
            isTrusted: isTrusted,
        }));
    };
    EventManager.prototype.setAnimationManager = function (animationManager) {
        this.animationManager = animationManager;
    };
    EventManager.prototype.destroy = function () {
        this._axes.off();
    };
    EventManager.prototype._createUserControll = function (pos, duration) {
        if (duration === void 0) { duration = 0; }
        var userControl = {
            destPos: __assign({}, pos),
            duration: duration,
        };
        return function (toPos, userDuration) {
            if (toPos) {
                userControl.destPos = __assign({}, toPos);
            }
            if (userDuration !== undefined) {
                userControl.duration = userDuration;
            }
            return userControl;
        };
    };
    EventManager.prototype._getRoundPos = function (pos, depaPos) {
        var roundUnit = this._axes.options.round;
        return {
            roundPos: roundNumbers(pos, roundUnit),
            roundDepa: roundNumbers(depaPos, roundUnit),
        };
    };
    EventManager.prototype._getBounceRatio = function (pos) {
        return this._axes.axisManager.map(pos, function (v, opt) {
            if (v < opt.range[0] && opt.bounce[0] !== 0) {
                return (opt.range[0] - v) / opt.bounce[0];
            }
            else if (v > opt.range[1] && opt.bounce[1] !== 0) {
                return (v - opt.range[1]) / opt.bounce[1];
            }
            else {
                return 0;
            }
        });
    };
    return EventManager;
}());
export { EventManager };
//# sourceMappingURL=EventManager.js.map