{"version":3,"file":"cfcs.min.js","sources":["../src/core/utils.ts","../src/reactive/const.ts","../src/reactive/Observer.ts","../src/reactive/utils.ts","../src/reactive/Reactive.ts","../src/reactive/ReactiveSubscribe.ts","../src/dom/utils.ts","../src/reactive/inlineReactive.ts","../src/reactive/adaptReactive.ts"],"sourcesContent":["/**\n * cfcs\n * Copyright (c) 2022-present NAVER Corp.\n * MIT license\n */\nexport function keys<T extends Record<string, any>>(obj: T): Array<keyof T> {\n  return Object.keys(obj);\n}\n\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]([a-z])/g, (all, letter) => letter.toUpperCase());\n}\n\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\nexport function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}","export const OBSERVERS_PATH = \"__observers__\";\nexport const REACTIVE_PATH = \"__reactive__\";\n","import Component from \"@egjs/component\";\n\ninterface EmitterEvents<Value> {\n  update: (value: Value) => void;\n}\n\nexport class Observer<Value = any> {\n  private _current: Value;\n  private _emitter = new Component<EmitterEvents<Value>>();\n\n  constructor(value?: Value) {\n    this._current = value as any;\n  }\n  public get current() {\n    return this._current as Value;\n  }\n  public set current(value: Value) {\n    const isUpdate = value !== this._current;\n    this._current = value;\n\n    if (isUpdate) {\n      this._emitter.trigger(\"update\", value);\n    }\n  }\n  public subscribe(callback: (value: Value) => void) {\n    this._emitter.on(\"update\", callback);\n  }\n  public unsubscribe(callback?: (value: Value) => void) {\n    this._emitter.off(\"update\", callback);\n  }\n}\n","import { OBSERVERS_PATH } from \"./const\";\nimport { Observer } from \"./Observer\";\nimport { ReactiveMethods } from \"./types\";\nimport { Ref } from \"../core\";\n\n\nexport function withReactiveMethods<\n  Instance,\n  Names extends keyof Partial<Instance>,\n  Return extends ReactiveMethods<Instance, Names>\n>(ref: Ref<Instance>, methods?: readonly Names[]): Return {\n  const obj: Record<any, any> = {};\n\n  if (!methods) {\n    return obj;\n  }\n\n  methods.forEach(name => {\n    obj[name] = function (...args: any[]) {\n      const current: any = ref.current || ref.value;\n\n      return current[name](...args);\n    };\n  });\n  return obj as Return;\n}\n\n\nexport function observe<Type>(defaultValue?: Type): Observer<Type> {\n  return new Observer<Type>(defaultValue);\n}\n\nexport function getObservers(instance: any): Record<string, Observer<any>> {\n  if (!instance[OBSERVERS_PATH]) {\n    instance[OBSERVERS_PATH] = {};\n  }\n  return instance[OBSERVERS_PATH];\n}\n\nexport function getObserver(instance: any, name: string, defaultValue?: any): Observer<any> {\n  const observers = getObservers(instance);\n\n  if (!observers[name]) {\n    observers[name] = observe(defaultValue);\n  }\n  return observers[name];\n}\n\nexport function setObserver(instance: any, name: string, observer: Observer<any>) {\n  const observers = getObservers(instance);\n\n  observers[name] = observer;\n}\n\nexport function isObserver(val: any): val is Observer {\n  return val && (\"current\" in val && \"subscribe\" in val && \"unsubscribe\" in val);\n}","import { getObserver } from \"./utils\";\n\nexport function Reactive(name?: string) {\n    return function (prototype: any, memberName: string) {\n        const publicName = name || memberName;\n\n        Object.defineProperty(prototype, memberName, {\n            get: function () {\n                return getObserver(this, publicName).current;\n            },\n            set: function (value: any) {\n                getObserver(this, publicName, value).current = value;\n            },\n        });\n        if (publicName !== memberName) {\n            Object.defineProperty(prototype, publicName, {\n                get: function () {\n                    return getObserver(this, publicName).current;\n                },\n            });\n        }\n    };\n}\n\n","import { keys } from \"../core\";\nimport { getObserver, getObservers } from \"./utils\";\n\nexport function injectReactiveSubscribe(object: Record<string, any>, ) {\n    object[\"subscribe\"] = function (name: string, callback: (value: any) => void) {\n        getObserver(this, name).subscribe(callback);\n    };\n    object[\"unsubscribe\"] = function (name?: string, callback?: (value: any) => void) {\n        if (!name) {\n            keys(getObservers(this)).forEach((observerName) => {\n                this.unsubscribe(observerName);\n            });\n            return;\n        }\n        if (!(name in this)) {\n            return;\n        }\n        getObserver(this, name).unsubscribe(callback);\n    };\n}\n\nexport function ReactiveSubscribe(Constructor: any) {\n    const prototype = Constructor.prototype;\n\n    injectReactiveSubscribe(prototype);\n}\n\nexport interface ReactiveSubscribe<Properties extends Record<string, any>> {\n    subscribe<Name extends keyof Properties = keyof Properties>(\n        name: Name, callback: (value: Properties[Name]) => void): void;\n    unsubscribe<Name extends keyof Properties = keyof Properties>(\n        name?: Name, callback?: (value: Properties[Name]) => void): void;\n}","\nexport function withClassMethods(methods: readonly string[]) {\n  return function (prototype: any, memberName: string) {\n    methods.forEach((name: string) => {\n      if (name in prototype) {\n        return;\n      }\n      prototype[name] = function (...args) {\n        const result = this[memberName][name](...args);\n\n        // fix `this` type to return your own `class` instance to the instance using the decorator.\n        if (result === this[memberName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n","import { ExtractNever, isFunction, keys } from \"../core\";\nimport { Observer } from \"./Observer\";\nimport { Reactive } from \"./Reactive\";\nimport { injectReactiveSubscribe, ReactiveSubscribe } from \"./ReactiveSubscribe\";\nimport { isObserver, setObserver } from \"./utils\";\n\n\ntype ConvertValue<Object extends Record<string, any>> = {\n    [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : Object[Key];\n}\n\ntype PickObverser<Object extends Record<string, any>> = ExtractNever<{\n    [Key in keyof Object]: Object[Key] extends Observer<infer Type> ? Type : never;\n}>;\n\nexport type ReactiveObject<Object extends Record<string, any>>\n    = ConvertValue<Object> & ReactiveSubscribe<PickObverser<Object>>;\n\nexport function reactive<Object extends Record<string, any>>(\n    setup: Readonly<Object> | (() => Readonly<Object>),\n): ReactiveObject<Object> {\n    const result = isFunction(setup) ? setup() : setup;\n    const reactiveObject: Record<string, any> = {};\n\n    keys(result).forEach((name: any) => {\n        const value = result[name];\n        if (isObserver(value)) {\n            setObserver(reactiveObject, name, value);\n            Reactive(name)(reactiveObject, name);\n        } else {\n            reactiveObject[name] = value;\n        }\n    });\n\n    injectReactiveSubscribe(reactiveObject);\n    return reactiveObject as ReactiveObject<Object>;\n}\n","import { keys } from \"src/core\";\nimport { Ref } from \"src/core/types\";\nimport { ReactiveAdapter } from \"./ReactiveAdapter\";\nimport { ReactiveSubscribe } from \"./ReactiveSubscribe\";\nimport { ReactiveEventCallback } from \"./types\";\nimport { getObservers, withReactiveMethods } from \"./utils\";\n\nexport function adaptReactive<\n    Instance extends ReactiveSubscribe<Record<string, any>>,\n    State extends Record<string, any> = {},\n    Methods extends keyof Partial<Instance> = any,\n    Data = any,\n    Events extends Record<string, any> = {},\n    >(adapter: ReactiveAdapter<Instance, State, Methods, Data, Events>) {\n\n    function data(): Data {\n        return adapter.data?.() ?? {} as Data;\n    }\n\n    const instanceRef: Ref<Instance> = { current: adapter.created?.(data()) || null };\n    let firstState: State | null = null;\n    \n    return {\n        state(): State {\n            const inst = instanceRef.current;\n\n            if (firstState) {\n                return firstState;\n            }\n            if (adapter.state) {\n                firstState = adapter.state;\n            } else if (inst) {\n                const observers = getObservers(inst);\n\n                firstState = keys(observers).reduce((prev, cur) => {\n                    prev[cur] = observers[cur].current;\n                    return prev;\n                }, {} as any);\n            }\n            return firstState || {} as State;\n        },\n        instance() {\n            return instanceRef.current;\n        },\n        mounted(): void {\n            instanceRef.current = adapter.mounted?.(data()) || instanceRef.current;\n        },\n        init(): void {\n            adapter.init?.(instanceRef.current!, data());\n        },\n        destroy(): void {\n            adapter.destroy?.(instanceRef.current!, data());\n        },\n        methods() {\n            return withReactiveMethods<any, any, any>(instanceRef, adapter.methods);\n        },\n        on(eventName: string, listener: ReactiveEventCallback<any, any>) {\n            adapter.on?.(instanceRef.current!, eventName as never, listener);\n        },\n        off(eventName: string, listener: ReactiveEventCallback<any, any>) {\n            adapter.off?.(instanceRef.current!, eventName as never, listener);\n        },\n    };\n}"],"names":["keys","obj","Object","isFunction","val","OBSERVERS_PATH","Observer","value","this","_emitter","Component","_current","__proto","prototype","defineProperty","get","set","isUpdate","trigger","subscribe","callback","on","unsubscribe","off","withReactiveMethods","ref","methods","forEach","name","args","_i","arguments","length","current","observe","defaultValue","getObservers","instance","getObserver","observers","setObserver","observer","isObserver","Reactive","memberName","publicName","injectReactiveSubscribe","object","_this","observerName","str","replace","all","letter","toUpperCase","result","_a","apply","setup","reactiveObject","Constructor","adapter","data","_b","call","instanceRef","created","firstState","state","observers_1","inst","reduce","prev","cur","mounted","init","destroy","eventName","listener"],"mappings":"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"}